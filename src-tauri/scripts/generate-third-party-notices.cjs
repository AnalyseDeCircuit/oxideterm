/* eslint-disable no-console */

const fs = require('fs');
const cp = require('child_process');

function exec(cmd) {
  return cp.execSync(cmd, {
    encoding: 'utf8',
    maxBuffer: 1024 * 1024 * 200,
    stdio: ['ignore', 'pipe', 'pipe']
  });
}

function escPipe(value) {
  return String(value ?? '').replace(/\|/g, '\\|').replace(/\r?\n/g, ' ');
}

function parseKey(key) {
  // Example key: "adler2 2.0.1 registry+https://github.com/rust-lang/crates.io-index"
  // Or: "oxideterm 0.5.0-beta1 path+file:///.../src-tauri"
  const parts = key.split(' ');
  const name = parts[0] || key;
  const version = parts[1] || '';
  const source = parts.slice(2).join(' ');
  return { name, version, source };
}

function buildNotices() {
  const generatedAt = new Date().toISOString();

  // Use cargo-deny since it's already installed in this repo.
  const raw = exec('cargo deny list -f json -l crate');
  const data = JSON.parse(raw);

  const crates = [];
  for (const [key, value] of Object.entries(data)) {
    const meta = parseKey(key);
    const licenses = Array.isArray(value.licenses) ? value.licenses : [];
    crates.push({
      ...meta,
      licenses
    });
  }

  crates.sort((a, b) => a.name.localeCompare(b.name) || a.version.localeCompare(b.version));

  // Filter out oxideterm before any statistics to avoid leaking local path
  // and polluting license counts with our own non-commercial license.
  const thirdPartyCrates = crates.filter(c => c.name !== 'oxideterm');

  const licenseCounts = new Map();

  function isCopyleft(lic) {
    return /^(A?GPL|LGPL)(-|$)/i.test(String(lic));
  }

  function isPermissive(lic) {
    const l = String(lic);
    return (
      l === 'MIT' ||
      l === 'Apache-2.0' ||
      l === 'BSD-2-Clause' ||
      l === 'BSD-3-Clause' ||
      l === 'ISC' ||
      l === '0BSD' ||
      l === 'Zlib' ||
      l === 'Unlicense' ||
      l === 'CC0-1.0'
    );
  }

  const copyleftStrict = [];
  const copyleftWithPermissiveOption = [];

  for (const c of thirdPartyCrates) {
    for (const lic of c.licenses) {
      licenseCounts.set(lic, (licenseCounts.get(lic) || 0) + 1);
    }

    const hasCopyleft = c.licenses.some(isCopyleft);
    if (!hasCopyleft) continue;

    const hasPermissive = c.licenses.some(isPermissive);
    if (hasPermissive) {
      copyleftWithPermissiveOption.push(c);
    } else {
      copyleftStrict.push(c);
    }
  }

  const summaryLines = [...licenseCounts.entries()]
    .sort((a, b) => b[1] - a[1])
    .map(([lic, count]) => `- ${lic}: ${count}`);

  let out = '';
  out += '# Third-Party Notices (Backend / Rust)\n\n';
  out += 'This file lists third-party crates used by the Rust backend and their detected licenses (including transitive dependencies).\n';
  out += `Generated: ${generatedAt}\n\n`;

  out += '## Summary\n';
  out += `${summaryLines.join('\n')}\n\n`;

  if (copyleftStrict.length || copyleftWithPermissiveOption.length) {
    out += '## Copyleft Notes\n\n';
    out += 'Crates can be multi-licensed. When a license list includes both copyleft and permissive licenses, it often means you may choose a permissive option (for example: `MIT OR Apache-2.0 OR LGPL-2.1-or-later`).\n';
    out += 'This report does not attempt to interpret SPDX boolean logic beyond simple grouping; treat this section as a review prompt if you distribute binaries.\n\n';
  }

  if (copyleftStrict.length) {
    out += '### Copyleft (no permissive option detected)\n\n';
    out += '| Crate | Version | Licenses | Source |\n|---|---:|---|---|\n';
    for (const c of copyleftStrict.sort((a, b) => a.name.localeCompare(b.name))) {
      out += `| ${escPipe(c.name)} | ${escPipe(c.version)} | ${escPipe(c.licenses.join(', '))} | ${escPipe(c.source)} |\n`;
    }
    out += '\n';
  }

  if (copyleftWithPermissiveOption.length) {
    out += '### Copyleft present, but permissive options also listed\n\n';
    out += '| Crate | Version | Licenses | Source |\n|---|---:|---|---|\n';
    for (const c of copyleftWithPermissiveOption.sort((a, b) => a.name.localeCompare(b.name))) {
      out += `| ${escPipe(c.name)} | ${escPipe(c.version)} | ${escPipe(c.licenses.join(', '))} | ${escPipe(c.source)} |\n`;
    }
    out += '\n';
  }

  out += '## Crates\n\n';
  out += '| Crate | Version | Licenses | Source |\n|---|---:|---|---|\n';
  for (const c of thirdPartyCrates) {
    out += `| ${escPipe(c.name)} | ${escPipe(c.version)} | ${escPipe(c.licenses.join(', '))} | ${escPipe(c.source)} |\n`;
  }
  out += '\n';

  out += '## Notes\n\n';
  out += '- **Multi-license policy**: Where a crate offers multiple licenses (e.g. `MIT OR Apache-2.0`), OxideTerm always exercises the most permissive option available.\n';
  out += '- License data is generated by `cargo deny list` and may include multiple licenses per crate.\n';
  out += '- This list is intended for notice/compliance purposes and does not replace the full license texts included by upstream projects.\n';

  return {
    out,
    count: thirdPartyCrates.length,
    copyleftCount: copyleftStrict.length + copyleftWithPermissiveOption.length
  };
}

function main() {
  const { out, count, copyleftCount } = buildNotices();
  const outputPath = 'THIRD_PARTY_NOTICES.md';
  fs.writeFileSync(outputPath, out);
  console.log(`Wrote ${outputPath} with ${count} crate entries (${copyleftCount} copyleft-flagged).`);
}

main();
